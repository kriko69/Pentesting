# ENUMERACION DE PUERTOS CON NAMP

## IDENTIFICACION DE EQUIPOS

Podemos descubrir maquinas a traves del protocolo ARP:

```
arp-scan -l
```

Protocoles de red:

* ARP: El protocolo ARP (Address Resolution Protocol) es el método estándar para obtener la dirección "física" (nivel 2 -capa de enlace-) de un equipo cuando únicamente se conoce su dirección "lógica" (nivel 3 -capa de red-).
* TCP: (capa de transporte) es uno de los protocolos fundamentales en Internet, nos permite que las aplicaciones puedan comunicarse con garantías independientemente de las capas inferiores del modelo TCP/IP. Debido a que TCP sirve a una gran cantidad de protocolos de la capa de aplicación, es fundamental que los datos (segmentos) lleguen correctamente al destinatario, sin errores, y, en orden. Si en la transmisión de los segmentos, se corrompiesen o perdiesen, automáticamente el protocolo TCP inicia la retransmisión, sin intervención de la capa de aplicación. 
* UDP: (capa de transporte) El protocolo UDP permite el envío de datagramas sin necesidad de establecer previamente una conexión, tan solo es necesario tener abierto un socket en el destino para que acepte los datagramas del origen. UDP es un protocolo no orientado a conexión, es decir, no ocurre como en TCP donde hay una fase de establecimiento de la conexión, aquí directamente se envían sin establecimiento previo «aviso». Este protocolo no proporciona ningún tipo de control de flujo, si un equipo es más rápido que otro y envía información, es muy posible que se pierda información debido a que colapsará al más lento, y tendremos que proceder al reenvío de la información.
* ICMP: permite adquirir información mediante pares de paquetes petición / respuesta, por ejemplo, para adquirir la máscara de red de un sistema o el valor de su reloj (timestamps). Se emplea para comprobar la existencia de conectividad, como en la utilidad "ping", empleando paquetes ICMP.

Pdemos obtener el gateway la siguiente manera:

´´´
route -n
´´´

Verificamos si la maquina esta activa enviandole una traza ICMP:

´´´
ping -c 1 192.168.1.1

-c: sirve para especificar cuantos paquetes enviar
´´´

A traves del can "ttl" podemos determinar elsistema operativo de la maquina:

|sistema operativo|valor ttl|
|-----------------|---------|
|Linux|64|
|Windows|128|

A vesces en el resultado del ping no sale exacto como muestra la tabla debido a que por cada salto el ttl disminuye pero sera menos 2 o 1 punto.

Para determinar la ruta que sigue una traza ICMP:

´´´
ping -c 1 192.168.1.1 -R

-R: sirve para mostrar la ruta del paquete
´´´

Como ya sabes como obtener el gateway podemos ver si la comunicacion con el equipo es directa o para a traves de un nodo intermedio

La identificacion del SO. de esta manera es menos ruidosa que usando nmap y los IDS no lo perciben.

## IDENTIFICACION CON NMAP

Ya cuando lo usamos con un CTF, lo mejor es primero crearse un directorio con el nombre de la maquina:

```
mkdir nombre_de_la_maquina
cd nombre_de_la_maquina
```

Dentro de la maquina nos creamosuna estructura de carpetas para tener un orden, por ejemplo:

```
mkdir {nmap,content,scripts,tmp,exploits}

lo ponemos agregar como funcion a la zshrc
```

* nmap: exportamos y tratamos la informacion de nmap.
* content: informacion obtenida de la maquina importante. (correos,usuarios)
* scripts: scripts creados personalmente.
* tmp: contenido temporal para uso en la maquina.
* exploits: los exploits de internet.

ingresamos a la carpeta nmap y empezamos con la fase de reconocimiento:

```
nmap 192.168.1.2 -p- --open -T5 -v -n -oG allPorts

192.1681.2 = IP de la victima
-p- = especifica todo elrango de puertos (65535 puertos)
--open = filtramos los que estan abiertos (eso es lo que nos interesa)
-T5 = escaneo veloz esto solo se usa en entornos controlados porqwue hace mucho ruido y te descubren
-v = verbose para que nos muestre los puertos apenas lo descubra
-n = especificamos que NO queremos una resolucion DNS (Esto hace tardar mas)
-oG = lo exportamos en formato grepeable
allPorts = nombre del fichero exportado
```

El formato grepeable nos ayudara de manera mas rapida filtrar los puertos creando una funcion en la zshrc:

```
function extractPorts(){
  echo -e "\n${yellowColour}[*] Extracting information...${endColour}\n"
  ip_address=$(cat allPorts | grep -oP "\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}" | sort -u)
  open_ports=$(cat allPorts | grep -oP "\d{1,5}/open" | awk '{print $1}' FS="/" | xargs tr " " ",") 
  echo -e "\t${blueColour}[*] IP Address: ${endColour}${greyColour}$ip_address${endColour}"
  echo -e "\t${blueColour}[*] Open ports: ${endColour}${greyColour}$open_ports${endColour}"
  echo $open_ports | tr -d "\n" | xclip -sel clip
  echo -e "${yellowColour}[*] Ports has been copied to clipboard!${endColour}"
}
```

Con esta funcion tenemos los puertos abiertos filtrados y copiados en la clipboard (ctrl + shift + V). Ahora enumeramoos sericios para esos puertos:

```
nmap -sC -sV -p(pegamos lo de extractPorts) 192.168.112.128 -oN targeted

-oN = exporta en formato nmap que es mas legible.
targeted = nombre del fichero de exportacion.   
```

En caso de tener el puerto 80 abierto podemos usar whatweb para conocer mas informacion acerca del servidor web:

```
whatweb http://192.168.112.128 2>/dev/null
```

## TECNICAS PARA AGILIZAR NUESTROS ESCANEOS

```
nmap -sS --min-rate 5000 --open -vvv -n -Pn -p- 192.168.112.128

-sS --min-rate 5000 = escaneo con el protocolo SYNC enviando paquetes NO mas que 5000 por segundo
```

Podemos crear una utilidad en bash para extrar de manera mas rapida los puertos abiertos:

```
#!/bin/bash

if [ $1 ];then
        ip_address=$1
        for port in $(seq 1 65535);do
                timeout 1 bash -c "echo '' > /dev/tcp/$ip_address/$port" 2>/dev/null && echo "[*] Port $port - OPEN" &
        done; wait
else
        echo -e "\n[!] Uso: ./portScan.sh <ip_address>\n"
        exit 1
fi

```

El if del $1 es para validar la existencia del primer parametro que debe ser la ip que queremos descubrir puertos, hacemos una secuencia de todos loos puertos en el for (son 65535 puertos los que existen), le decimos que espere un minuto (timeout 1) en la ejecucion de (bash -c ) y enviamos algo vacio a la ruta /dev/tcp/$ip_address/$port donde la salida de error la mandams al /dev/null, si esta abierto se ejecuta lo que esta despues del '&&' donde mostramos un mensaje indicando que el puerto esta abierto, con el signo '&' al final indicamos que loo ejecute en segundo plano o en un hilo diferente por iteracion y con la sentencia wait le decimoos que espere hasta que la respuesta este lista porque es un proceso asincrono. 

ya que es un proceso asincrono puede que un hilo se ejecute antes que otro y puede salir:
puerto 5 abierto
puerto 2 abierto

ya que es una secuencia se espera que los mensajes salgan en orden ascendente segun el puerto pero el proceso asincrono hace variar esto segun la rapidez de la respuesta.

En todo caso solo afecta a la salida del mensaje mas no en el escaneo y dara como resultado correctamente todos los puertos abiertos.
