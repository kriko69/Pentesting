# ENTENDIENDO EL BUFFER OVERFLOW 

| x86 | x64 |
|:---:|:---:|
| EBP | RBP |
| EIP | RIP |
| ESP | RSP |
| EAX | RAX |
| ESI | RSI |


## ENSAMBLADOR x86

### PUSH Y POP

Basicamente Push agrega datos a la pila y pop los quita de la pila.
Se dice que push diminuye, en una rquitectura de 32 bits 4 bytes a la pila y en en una arquitectura de 64 bits 8 bytes a la pila, porque imaginemos que la pila tiene un almacenamiento de 200 bytes, sabemos que para los datos que ingresen  se reserva 4 bytes en la pila por lo que al ingresar valores a la pila (PUSH) la pila decrementa de 200 a 196 y cuando se saca valor de la pila (POP) la pila incrementa su valor.



al inicio se tiene

```
push    ebp
mov ebp, esp
```
Estas instrucciones se conocen como el prólogo de la función de ensamblador. Las primeras 2 instrucciones guardan el puntero base pointer (ebp) y establecen EBP para que apunte a esa posición en la pila (justo debajo de la dirección de retorno EIP).

* push ebp -> ingresa el registro EBP en la pila. (para ser utilizada)
* mov ebp, esp -> copia el valor de ESP en EBP, esto es porque se hace una copia de seguridad del registro ESP, de modo que al finalizar la funcion y en caso que esta funcion cambie el valor de ese registro el ESP pueda ser reestablecido. Dentro de la funcion al existir una copia de ESP, este registro puede puede almacenar nuevos valores, resulñtados de operaciones y al finalizar antes de retornar a la funcion principal se realiza la restauracion de este registro.

al final se tiene

```
mov esp, ebp \
              === leave
pop ebp      /
ret
```

Esto es lo inverso que hace el prólogo (es decir, el epílogo), por lo que se puede restaurar el contexto anterior.
La leave instrucción hace exactamente lo que hacen estas dos instrucciones

### Instruccion call

Un programa de computadora realiza un seguimiento de dos punteros importantes mientras se ejecuta: el puntero de instrucción, que apunta a la siguiente instrucción que ejecutará, y el puntero de pila, que apunta al último valor introducido en la pila. En x86, el puntero de instrucción es el registro %eipy el puntero de pila está en el registro %esp.

La pila crece hacia abajo (a medida que los valores se introducen en la pila, el puntero de la pila disminuye) y se divide lógicamente en regiones. El registro ESP en diagramas se lo ubica en la parte baja del stack y se dice que es la cima de la pila, pero esto es porque la pila crece hacia abajo y la cima estara en la parte inferior.

Cuando se llama a una función (mediante call), el puntero de instrucción (EIP) se inserta en la pila para permitir que el programa regrese al sitio de la última instruccion call. Antes de call, el puntero de instrucción apunta a la instrucción call y el puntero de pila (ESP) apunta a lo último que se empujó (en este caso, algún valor de basura):

UBICACION DE EIP

```
%eip => 0x00001f66: call   0x1ef0 <nop_ret> (la funcion en este caso se llama ret)

        0x00001f6b: movl   $0x0,-0x8(%ebp)

```

CONTENIDO DE ESP

```
0xdeadcafe (valor basura o cualquiera)
```

Después de call, el puntero de instrucción (EIP) apunta a la primera instrucción en nuestra función (ret) y el puntero de pila apunta a instruccion abajo de call, la dirección de retorno de nuestra función (0x00001f6b):

```
%eip => 0x00001ef0: ret | | 0xdeadcafe | 

%esp => 0x00001f6b
```

En este caso, la función no hace nada y simplemente regresa (return). La instrucción ret saca un valor de la pila y lo ingresa al EIP. Esto incrementa el puntero de la pila y devuelve el flujo de control a la función de llamada:

```
        0x00001f66: call   0x1ef0 <nop_ret> (la funcion en este caso se llama ret)

%eip => 0x00001f6b: movl   $0x0,-0x8(%ebp)

```

CONTENIDO DE ESP

```
0xdeadcafe (valor basura o cualquiera)
```

### argumentos

Cuando se llama a una función (mediante call) que necesita argumentos, se insertan en la pila inmediatamente antes de la instruccion call. Si hay más de un argumento, el primer argumento pasa al último. La siguiente secuencia de operaciones corresponde a la llamada de función proj_1(0x5, 0x10):

```
% eip => 0x00001f78: pushl $0x10   | | 0xdeadbeef <= %esp (un valor basura en el ESP)
        0x00001f7a: pushl $0x5  
        0x00001f7c: call 0x1f90 <proj_1> 
        0x00001f81: addl $0x8,%esp       
```

```
        0x00001f78: pushl $0x10 | | 0xdeadbeef 
% eip => 0x00001f7a: pushl $0x5 | | 0x10 | <= %esp 
        0x00001f7c: call 0x1f90 <proj_1>
        0x00001f81: addl $0x8,%esp    
```

```
        0x00001f78: pushl $0x10 | | 0xdeadbeef 
        0x00001f7a: pushl $0x5 | | 0x10  
% eip => 0x00001f7c: call 0x1f90 <proj_1> | | 0x5 | <= %esp 
        0x00001f81: addl $0x8,%esp 
```

Es más común ver argumentos en la pila a través de instrucciones mov en lugar de las instrucciones push. El siguiente bloque de código también llamaría proj_1(0x5, 0x10):

```
subl $0x8, %esp      # Reserva espacio para los argumentos (4 bytes por cada argumento, son 2 argumentos).
movl $0x10, 4(%esp)  # Pone el primer argumento en la dirección de memoria %esp + 4.
movl $0x5, (%esp)    # Pone el segundo argumento en la dirección de memoria %esp 
call proj_1          # Se lama a la funcion
addl $0x8, %esp      # Recupere el espacio de pila reservado para argumentos.
ret
```

### Valores de retorno

Como puede ver, los argumentos están por encima de la dirección de retorno en la pila inmediatamente antes de la llamada a la función. En este caso, nuestra función devuelve simplemente el primer argumento ($0x10). La instruccion mov 0x4(%esp), %eax mueve el valor de registro ESP agregandole 4 (ESP_REG+4) en %eax. Por norma, el valor de retorno de una función se guarda en %eax.

```
%eip => 0x00001f90: mov    0x4(%esp),%eax         |      | 0xdeadbeef | 
        0x00001f94: ret                           |      | 0x10       |
                                                  |      | 0x5        |
                                                  |      | 0x00001f81 | <= %esp
```

```
        0x00001f90: mov    0x4(%esp),%eax         |      | 0xdeadbeef | 
%eip => 0x00001f94: ret                           |      | 0x10       |
                                                  |      | 0x5        |
                                                  |      | 0x00001f81 | <= %esp
```

El retorno

```
        0x00001f78: pushl  $0x10                  |      | 0xdeadbeef |
        0x00001f7a: pushl  $0x5                   |      | 0x10       |
        0x00001f7c: call   0x1f90 <proj_1>        |      | 0x5        | <= %esp
%eip => 0x00001f81: addl   $0x8, %esp             |      |            |
```
La instrucción ret hace que el registro "esp" aumente en 4.
La instrucción ret saca la dirección de retorno de la pila (a la que apunta el registro del puntero (EIP) de la pila) en este caso  0x00001f81 (seccion 2 del codigo) y luego continúa la ejecución en esa dirección. (seccion 3 del codigo)

La pila aumenta mas 4 y el ESP apunta ahora al siguiente valor de la pila. (0x5)

### Base pointer (EBP) y variables locales

El puntero base (EBP) se usa convencionalmente para marcar el inicio de la pila de una función, o el área de la pila administrada por esa función. Las variables locales se almacenan debajo del puntero base (EBP) y encima del puntero de la pila (EIP). 

```

STACK
 --------------
|  funciones   |     |
 --------------      |
|  parametros  |     |
 --------------      |
|     EIP      |     |
 --------------      |
| VAR. LOCALES |     | (Variables locales)
 --------------      |
|     EBP      |     | (El EBP apunta a la base del la pila - BUFFER)
 --------------      |
|     BUFFER   |     |
 --------------      ↓ (como el stack crece hacia abajo esta es la cima ESP)

```


El inicio de cada función tiene un inicio en donde guarda el puntero base anterior e inicializa uno nuevo y el final de cada función tiene un epílogo que restaura el puntero base anterior:

```
mi_funcion: 
  push  %ebp                   # Inicio: guarda el antiguo %ebp. 
  movl  %esp, %ebp             # Apunte al nuevo %ebp y lo pone en la pila

  subl  $0x4,%esp              # Reserva espacio (4) para variables locales. 

  movl  0x8(%ebp),%eax    
  movl  %eax, -0x4(%ebp)       # Mueve el argumento a la variable local. 

  # Cuerpo de la función. 

  addl  $0x4 , %esp         # Recuperar el espacio utilizado por las variables locales. 

  pop  %ebp                # Epílogo: restaurar el antiguo %ebp. 
  ret
```

Dentro de la funcion la pila queda asi:

```
| <argumento 2> | 
| <argumento 1> | 
| <dirección de retorno> | 
| <antiguo ebp> | <= %ebp 
| <var local 1> | 
| <var local 2> | <= %esp
```

### Guardar rgistros

Dentro de una función, puede utilizar libremente %eax, %ecx y %edx. Sin embargo, no se garantiza que sean persistentes en las llamadas a otras funciones, por lo que debe guardarlas antes de llamar a otras funciones. Si usa cualquier otro registro, debe asegurarse de guardarlos antes de usarlos y restaurarlos a los valores originales antes de regresar (hacer un ret). El siguiente bloque de código demuestra la forma correcta de guardar %ebx y %ecx:

```
mi_funcion: 
  push %ebp               # Inicio: guarda el antiguo %ebp. 
  movl %esp,%ebp 
  push %ebx               # Guarda %ebx antes de usarlo. 

  # Cuerpo de la función. 

  push %ecx               # Guarda %ecx antes de una llamada de función.  
  call <otra_funcion> 
  pop  %ecx               # Restaura %ecx después de llamar a una función. 

  pop  %ebx               # Restaura %ebx antes de regresar. 
  pop  %ebp               # Epílogo: restaurar el antiguo %ebp. 
  ret
```

### TOME NOTA

* %esp apunta a la última cosa empujada en la pila. (ultimo push)
 *%eip apunta a lo siguiente a ejecutar.
* call <addr> empuja el valor actual de %eip y cambia %eip a <addr>.
* ret saca el siguiente valor de la pila y lo guarda en %eip.
* Los argumentos se insertan en la pila antes de la llamada a una función.
* Inmediatamente después de la llamada a la función, la pila se ve así:

```
| <argumento 2> | 
| <argumento 1> | 
| <dirección de retorno> | <=% esp
```

* Dentro de una función, la pila se ve así:

```
| <argumento 2> | 
| <argumento 1> | 
| <dirección de retorno> | 
| <antiguo% ebp> | <=% ebp 
| <var local 1> | 
| <var local 2> | <=% esp
```

* El valor de retorno de una función está en %eax.

* %eax, %ecx y %edx son registros de guardado de llamadas (caller registers). Se los ingresa a la pila antes de llamar a otra funcion. Se utilizan para almacenar cantidades temporales que no necesitan conservarse entre llamadas, por lo que no garantiza persistencia en su almacenamiento.
* %ebp, %ebx, %edi, Y %esi son (callee registers). Se los ingresa a la pila antes de usarlas en la funcion. Se utilizan para mantener valores de larga duración que deben conservarse en todas las llamadas.



