# BASH SCRIPTING COMANDOS PARA INCORPORAR A UN SCRIPT

## seq (para la creacion de secuencias)

```
seq 10 -> 1 2 3 4 5 6 7 8 9 10
el inicio siempre sera 1

seq 3 10 -> 3 4 5 6 7 8 9 10
definiendo inicio y fin

seq 3 2 10 -> 3 5 7 9
definiendo inicio, salto y fin

seq -f "usuario %g2:" 2 5  -> usuario 2: usuario 3: usuario 4: usuario 5: 
-f de formato y con %g2 ponemos una de las anteriores secuencias en un texto

seq -f "hola %g2" 2 2 10

seq -s ":" 2 5 -> 2:3:4:5
-s de separador

seq -w 2 5 -> 02 03 04 05
agrega un 0 al inicio
```

## tr para transformar una cadena

### archivo: data = hola chris

```
cat data | tr "[a-z]" "[A-Z]" -> HOLA CHRIS
convierte a mayusculas

 o tambien esto  hace lo mismo

cat data | tr "[:lower:]" "[:upper:]"

reemplazar espacio por tab

cat data | tr [:space:] "\t"

reemplazar {} por ()

cat data | tr "{}" "()"

para eliminar un caracter repetido en este caso espacios ej: "hola     mundo" => " hola mundo"

cat data | tr -s [:space:] ""

eliminar un terminado carater

cat data | tr -d 'h'  --> elimina la o las h

se puede eliminar los digitos

cat data | tr -d [:digits:]

para eliminar todo menos los digitos (lo contrario)

cat data | tr -cd [:digits:]
```

## bc (basic calculator)

```
echo "9 / 2" | bc => 4

echo "9/ 2" | bc -l => 4.5

```

## VARIABLES 
[http://www.compciv.org/topics/bash/variables-and-substitution/](http://www.compciv.org/topics/bash/variables-and-substitution/)

```
numero=10
echo $numero
echo "mi numero es $numero"

soy=$(whoami)
echo "hola ${soy}" => puedes poner $soy o ${soy} en si es mejor el con llaves para concatenar con otras cadenas

para hacer funciones aritmeticas

$numero1=30
$numero2=13
$suma=$(($numero1+$numero2))  => se usa $(())

echo $suma
echo $(($numero1+$numero2))

```

## EXPRESIONES NUMERICASEXPRESIONES NUMERICAS

### siempre enre (())

```
## Post-increment example 
$ var=10
$ echo $((var++))  ## First print 10 then increase value by 1
 
## Pre-increment example
$ var=10
$ echo $((++var))  ## First increase value by 1 then print 11 

## Post-decrement example 
$ var=10
$ echo $((var--))  ## First print 10 then decrease value by 1
 
## Pre-decrement example
$ var=10
$ echo $((--var))  ## First decrease value by 1 then print 9
```

## VARIABLES ESPECIALES

```
$0 -> es el nombre del script
$1 - $9 -> argumentos del script, a partir del decimo argumento se usa llaves, ${10},${11}, etc.
$? -> verificamos el codigo de ejecucion de un comando
$! -> devuelve el ultimo atributo de un comando
$# -> devuelve el numero de argumentos del script
$@ -> devuelve todos los argumentos del script

args=("$@")
echo "First->"  ${args[0]}

$$ -> devuelve el PID del proceso del script
$* -> retorna todos los argumentos del script pero con comillas dobles

```

## ENTRADA DE DATOS

```
read variable -> lee una variable con salto de linea
read -p "mensaje" variable -> lee una variable en una sola linea
read -sp "mensaje" variable -> lee una variable en una sola linea pero no se muestra que se escribe (ideal para contrraseÃ±as)

con echo -e "" -> puede poner las variables dentro de las comillas con el simbolo $ ademas de usar \n o \t y el echo lo interpretara

```

## COMENTARIOS

```
#        -> para una sola linea

<<COMMENTS
muchas lineas para comentar
COMMENTS

: '
muchas lineas para comantar
'
```

## QUOTES

```
"" -> para cadenas simples  y para imprimir una variable
'' -> para cadenas simples

nombre="chris"
echo "$nombre" -> devuelve chris
echo '$nombre' -> devuelve $nombre"" -> para cadenas simples  y para imprimir una variable
'' -> para cadenas simples

nombre="chris"
echo "$nombre" -> devuelve chris
echo '$nombre' -> devuelve $nombre
```

## DEPURACION

```
bash -xv mi_script.sh
```

## CODIGOS DE EJECUCION

```
0 -> denota que el comando tiene una salida valida
1 -> la salida tiene un error (va desde el numero 1 - 255)
```

## grep (filtrado)

```
grep -E "hola|adios" => filtra por hola y por adios

o sino

grep -e "hola" -e "adios" data.txt

existe muchas variantes de grep, una de ellas es:

egrep => es igual a grep -E

buscar letras consecutivas

grep -E o\{2}  => (sin comillas) busca que haya 2 letras 'o' consecutivas

busqueda recursiva

1.- nos situamos en un directorio

...$ grep -r "hola"

```

## FIND (buscar)

```
find [ruta] -opcion parametro

find . -name data.txt => busqueda por nombre

find /home -name data.txt => en la ruta /home 

find . -iname data.txt => busqueda por nombre sin case sensitive (data, Data)

find . -type d/f -name data => busqueda por tipo 'd' directorio y 'f' file

find . -type f -name "*.php" => buscar todos los archivos de una extension

find . -type f -perm 0775 -print => encontrar archivos con un cierto permiso

find . -type f ! -perm 777  => encontrar archivos sin un determinado permiso

find . -perm /u=r => permiso de usuario para lectura

find . -name data.txt -exec rm -rf {} \; => buscar un archivo y eliminarlo (o ejecutar algun comando)

find . -empty => buscar archivos vacios

```

## SORT (ordenar archivos o su contenido)

```
sort data.txt => ordena el archivo data

sort -ordenado.txt data.txt => se define la salida

sort data.txt > ordenado.txt => se define una salida

sort -r data.txt =>ordena reversamente

sort -n numeros.txt => ordena un archivo a nivel numerico

sort -nr numeros.txt => orena reversamente numeros

sort -k 2 data.txt => ordena segun la segunda columna
EJ:

asd 100			asd 100
ad 400		=>	de 300
de 300			ad 400

sort -u data.txt => ordena y elimina los duplicos (-uniq)

*Si lo ponemos con | ordena la salida del comando anterior

cat data.txt | sort

```

## HEAD 

```
head -n 5 data.txt => muestra solo las 5 primeras lineas

head -c 5 data.txt => muestra los 5 primeros caracteres
```

## TAIL (lo contrario de head)

```
tail -n 5 data.txt => muestra solo las 5 ultimas lineas

tail -c 5 data.txt => muestra los 5 ultimos caracteres
```

## WC

contar lineas, ficheros y directorios

```
ls | wc -l  ->contamos cuantos directorios y ficheros hay

con ls -a podemos contar los ocultos mas

fichero.txt | wc -l  -> contamos las lineas
fichero.txt | wc -m  -> contamos los caracteres

```